#AgentCodeStarted
import os
import logging
from flask import request
import json


LOG_DIR = "/data/logs/d695304ca93d4969/d695304ca93d4969_1"
LOG_FILE = os.path.join(LOG_DIR, "d695304ca93d4969_1.log")
os.makedirs(LOG_DIR, exist_ok=True)
os.makedirs("/data/output/d695304ca93d4969", exist_ok=True)

logging.basicConfig(
    filename=LOG_FILE,
    filemode="a",
    format="%(asctime)s - %(levelname)s - %(message)s",
    level=logging.INFO
)


######################################################
# 1. JSON ARRAY EXTRACTOR (ROBUST AGAINST ']]]' ETC.)
######################################################
def extract_json_array(raw: str):
    start = raw.find("[")
    if start == -1:
        return None

    open_brackets = 0
    end = None

    for i, ch in enumerate(raw[start:], start=start):
        if ch == "[":
            open_brackets += 1
        elif ch == "]":
            open_brackets -= 1
            if open_brackets == 0:
                end = i + 1
                break

    if end is None:
        return None

    json_str = raw[start:end]

    try:
        return json.loads(json_str)
    except Exception as e:
        logging.error("JSON loads failed on substring:\n%s", json_str)
        return None


######################################################
# 3. UPDATED: PARSE selected_evidence_docs (instead of cognitive_output)
######################################################
def transform_selected_docs_to_dirs(selected_docs):
    """
    Convert selected_evidence_docs into:
        Company -> /data/{Company}/{file}
    preserving old behavior from cognitive_output parser.
    """

    final_dict = {}

    for entry in selected_docs:
        company = entry.get("Company_name")
        missing_flag = str(entry.get("Evidence_missing", "FALSE")).upper()
        files = entry.get("Evidence_files", [])

        # Missing evidence = "Missing"
        if missing_flag == "TRUE" or not files:
            final_dict[company] = "Missing"
            continue

        # Build paths: EXACTLY like old behavior
        file_paths = [f"/data/{company}/{filename}" for filename in files]

        # Single file → return string not list
        final_dict[company] = file_paths[0] if len(file_paths) == 1 else file_paths

    return final_dict


######################################################
# 4. MERGE WITH IQ/CONTROL SET (unchanged)
######################################################
def merge_directory_with_iq(directory_dict, companies_iq_control):
    merged = {}

    for company, directory_info in directory_dict.items():
        iq_info = companies_iq_control.get(company, {})
        merged[company] = {
            "Directory": directory_info,
            "Control_Set_ID": iq_info.get("Control_Set_ID", "Missing"),
            "IQ_ID": iq_info.get("IQ_ID", "Missing")
        }

    return merged


######################################################
# 5. MAIN — NOW ONLY USES selected_evidence_docs
######################################################
def main():
    try:
        logging.info("*************** Evidence Directory + IQ Merge Triggered ***************")

        data = request.get_json(force=True)

        raw_docs = data.get("selected_evidence_docs")
        companies_iq_control = data.get("companies_iq_control")

        if raw_docs is None:
            raise Exception("selected_evidence_docs missing from request")

        # Parse robustly
        if isinstance(raw_docs, list):
            selected_docs = raw_docs
        else:
            selected_docs = extract_json_array(str(raw_docs))

        if selected_docs is None:
            raise Exception("Failed to parse selected_evidence_docs JSON")

        # Produce directories (replaces cognitive_output logic)
        directory_dict = transform_selected_docs_to_dirs(selected_docs)

        # Merge with IQ/Control set (original behavior preserved 1:1)
        final_merged_dict = merge_directory_with_iq(directory_dict, companies_iq_control)

        logging.info("Evidence Directory + IQ Merge Completed")

        return {
            "status": "success",
            "final_merged_dict": final_merged_dict
        }

    except Exception as e:
        logging.error("Exception: %s", str(e))
        return {"status": "error", "message": str(e)}

#AgentCodeEnded
