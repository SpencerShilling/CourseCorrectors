# Packages
import requests
import pandas as pd
from datetime import datetime
import json, os, re
from typing import Tuple, List, Dict, Any
from IPython.display import display

# variables
BASE_URL = 
USERNAME = 
PASSWORD - 

TTILE = #e.g., 10
SECTION = '' #e.g., 52.55

# helpers
def login(username: str, password: str) -> str:
    """POST /v1/auth/login -> returns JWT access token."""
    url = f"{BASE_URL}/v1/auth/login"
    r = requests.post(url, json={"username": username, "password": password}, timeout=30)
    r.raise_for_status()
    return r.json()["access_token"]

def auth_hdr(token: str) -> dict:
    return {"Authorization": f"Bearer {token}"}

def get_title(token: str, number: int) -> dict:
    url = f"{BASE_URL}/v1/ecfr/titles/{number}"
    r = requests.get(url, headers=auth_hdr(token), timeout=30)
    r.raise_for_status()
    return r.json()

def get_section(token: str, title_number: int, section_identifier: str) -> dict:
    url = f"{BASE_URL}/v1/ecfr/titles/{title_number}/sections/{section_identifier}"
    r = requests.get(url, headers=auth_hdr(token), timeout=30)
    r.raise_for_status()
    return r.json()

# return raw checklist
def get_checklist(token: str, title_number: int, section_identifier: str) -> dict:
    url = f"{BASE_URL}/v1/ecfr/titles/{title_number}/sections/{section_identifier}/checklist"
    headers = {**auth_hdr(token), "Accept": "application/json"}
    r = requests.get(url, headers=headers, timeout=60)

    if r.status_code == 404:
        return {"_error": "not_found", "status": 404, "url": url, "body": r.text}

    r.raise_for_status()

    try:
        return r.json()
    except ValueError:
        return {"_error": "non_json_response", "status": r.status_code, "url": url, "body": r.text}

# parse raw checklist into formatted table
def _extract_section_header(t: str):
    m = re.search(r"§\s*([\d\.]+)\s+([^\n]+)", t)
    if not m: 
        return None, None
    return m.group(1).strip(), m.group(2).strip().rstrip(".")

def _extract_fr_citations(t: str) -> List[str]:
    fr = re.findall(r"(\d+\s*FR\s*\d+,\s*[A-Za-z]+\s+\d{1,2},\s*\d{4})", t)
    br = re.findall(r"\[(\d+\s*FR\s*\d+,\s*[^\]]+)\]", t)
    seen, out = set(), []
    for x in fr + br:
        if x not in seen:
            seen.add(x); out.append(x)
    return out

def _tokenize_paragraphs(t: str) -> List[str]:
    t = re.sub(r"[ \t]+", " ", t)
    return [p.strip() for p in re.split(r"\n\s*\n+", t) if p.strip()]

_ENUM_PAT = re.compile(r"^\((?P<tag>[a-zA-Z0-9ivxIVX]+)\)\s*(?P<body>.*)", re.DOTALL)

def _level_for_tag(tag: str) -> int:
    if re.fullmatch(r"[a-z]", tag): return 1
    if re.fullmatch(r"\d+", tag): return 2
    if re.fullmatch(r"[ivxIVX]+", tag): return 3
    if re.fullmatch(r"[A-Z]", tag): return 1
    return 4

def _parse_enumerations(paras: List[str]) -> List[Dict[str, Any]]:
    items, stack = [], []
    current = {"path": [], "text": ""}

    def flush():
        nonlocal current
        if current["text"].strip():
            items.append({"path": current["path"][:], "text": current["text"].strip()})
        current = {"path": [], "text": ""}

    for p in paras:
        m = _ENUM_PAT.match(p)
        if m:
            flush()
            tag = m.group("tag")
            body = m.group("body").strip()
            level = _level_for_tag(tag)
            stack = [s for s in stack if s[0] < level]
            stack.append((level, tag))
            current["path"] = [t for _, t in stack]
            current["text"] = body
        else:
            current["text"] += (" " if current["text"] else "") + p

    flush()
    return [i for i in items if i["path"]]

# parse markdown style table into rows
def _parse_md_table(md: str) -> List[Dict[str, str]]:
    """
    Extract the first Markdown table found in `md` and return list of dict rows.
    Supports headers like:
      Number | Sub-Section | Compliance Name | ...
      ---    | ---         | ---             | ...
    """
    lines = [ln.strip() for ln in md.splitlines()]
    # find header line that looks like a table (has pipes) and a following separator row of --- cells
    for i in range(len(lines) - 1):
        if "|" in lines[i]:
            hdr_cells = [c.strip() for c in lines[i].split("|") if c.strip() != ""]
            sep = lines[i+1]
            # separator must be at least e.g. --- | --- | ---
            if "|" in sep and all(re.match(r"^:?-{3,}:?$", c.strip() or "---") for c in sep.split("|")):
                headers = hdr_cells
                rows = []
                j = i + 2
                while j < len(lines) and "|" in lines[j] and lines[j].strip() != "":
                    vals = [c.strip() for c in lines[j].split("|")]
                    # align to headers length
                    vals = [v for v in vals if v != ""]  # drop empties from leading/trailing pipes
                    # pad/trim
                    if len(vals) < len(headers):
                        vals += [""] * (len(headers) - len(vals))
                    if len(vals) > len(headers):
                        vals = vals[:len(headers)]
                    row = dict(zip(headers, vals))
                    rows.append(row)
                    j += 1
                return rows
    return []

def format_checklist(raw: Any, citation_hint: str = None) -> Tuple[List[Dict[str, Any]], pd.DataFrame]:
    """
    Accepts:
      - dict with 'checklist_items': [...]
      - dict with 'checklist': '<markdown>'               (single block)
      - dict with 'checklist': [ '<mdtable>', ... ]       (list of tables)  <-- NEW
      - dict with nested checklist (e.g., raw['data']['checklist'])
      - bare string (markdown)
    Returns (rows, DataFrame). Always yields at least one row if any text/table is present.
    """
    def _find_markdown(d: dict):
        # Return ('string' | ['list', ...]) or None
        if "checklist" in d:
            return d["checklist"]
        for k in ("data", "result", "payload", "content"):
            if isinstance(d.get(k), dict) and "checklist" in d[k]:
                return d[k]["checklist"]
        return None

    rows: List[Dict[str, Any]] = []

    # Case A: bare string
    if isinstance(raw, str) and raw.strip():
        md = raw
        md_list = None

    # Case B: dict (includes safety markers and array-of-md)
    elif isinstance(raw, dict):
        if raw.get("_error") in {"not_found", "non_json_response"}:
            return rows, pd.DataFrame()

        # already-structured array
        if isinstance(raw.get("checklist_items"), list):
            items = raw["checklist_items"]
            for idx, item in enumerate(items, 1):
                row = dict(item)
                row.setdefault("control_id", f"item_{idx}")
                if citation_hint: row.setdefault("citation", citation_hint)
                rows.append(row)
            return rows, pd.json_normalize(rows, sep=".")

        # markdown string or list
        found = _find_markdown(raw)
        if isinstance(found, list):
            md_list = [s for s in found if isinstance(s, str) and s.strip()]
            md = None
        elif isinstance(found, str):
            md = found
            md_list = None
        else:
            return rows, pd.DataFrame()

    else:
        return rows, pd.DataFrame()

    # ---- Path 1: checklist is a list of markdown tables ----
    if md_list:
        all_rows: List[Dict[str, Any]] = []
        for block in md_list:
            table_rows = _parse_md_table(block)
            # capture any section header visible in the block
            sec_num, sec_title = _extract_section_header(block)
            citation = citation_hint or (f"10 CFR {sec_num}" if sec_num else "")
            # annotate each row with citation/section if possible
            if table_rows:
                for r in table_rows:
                    r_ = dict(r)
                    r_["citation"] = citation
                    r_["section_title"] = sec_title or ""
                    all_rows.append(r_)
        if all_rows:
            df = pd.json_normalize(all_rows, sep=".")
            return all_rows, df
        # Fallback: no table detected → treat each block as one big row
        fallback = []
        for idx, block in enumerate(md_list, 1):
            sec_num, sec_title = _extract_section_header(block)
            citation = citation_hint or (f"10 CFR {sec_num}" if sec_num else "")
            fallback.append({
                "control_id": f"block_{idx}",
                "citation": citation,
                "section_title": sec_title or "",
                "text": block.strip()
            })
        return fallback, pd.json_normalize(fallback, sep=".")

    # ---- Path 2: single markdown block (enumerations) ----
    if md:
        section_num, section_title = _extract_section_header(md)
        citation = citation_hint or (f"10 CFR {section_num}" if section_num else "")
        fr_notes = _extract_fr_citations(md)
        enum_items = _parse_enumerations(_tokenize_paragraphs(md))

        if enum_items:
            for ei in enum_items:
                path = ei["path"]
                control_id = (f"{section_num}(" + ")(".join(path) + ")") if section_num else "(" + ")(".join(path) + ")"
                rows.append({
                    "control_id": control_id,
                    "citation": citation,
                    "section_title": section_title or "",
                    "path": path,
                    "text": ei["text"],
                    "fr_citations": fr_notes
                })
        else:
            rows = [{
                "control_id": "raw-markdown",
                "citation": citation,
                "section_title": section_title or "",
                "path": [],
                "text": md.strip(),
                "fr_citations": fr_notes
            }]

        return rows, pd.json_normalize(rows, sep=".")

    return rows, pd.DataFrame()

def show_checklist_table(raw: Any, title_number: int, section_identifier: str, save_csv: bool = True) -> pd.DataFrame:
    """Formats and displays the full checklist table; always attempts a best-effort table."""
    citation_hint = f"{title_number} CFR {section_identifier}"
    rows, df = format_checklist(raw, citation_hint=citation_hint)

    if df.empty:
        print("No formatted checklist rows found (payload didn’t include checklist text or items).")
        try:
            print("\nRaw payload preview:")
            print(json.dumps(raw, indent=2, ensure_ascii=False)[:4000])
        except Exception:
            print(str(raw)[:2000])
        return df

    pd.set_option('display.max_rows', None)
    pd.set_option('display.max_colwidth', 200)
    print(f"Formatted checklist rows: {len(df)}")
    display(df)

    if save_csv:
        out_csv = f"checklist_T{title_number}_S{str(section_identifier).replace('.','_')}.csv"
        df.to_csv(out_csv, index=False)
        print("Saved CSV →", out_csv)

    return df
